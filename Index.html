
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Atomic Eraser Fixed</title>
    <style>
        html, body { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background: #020202; touch-action: none; }
        canvas { display: block; width: 100vw; height: 100vh; }
        #ui-panel {
            position: absolute; top: 10px; left: 10px;
            background: rgba(0, 0, 0, 0.85); padding: 12px;
            border-radius: 10px; color: #fff; border: 1px solid #555;
            width: 260px; z-index: 100; font-family: sans-serif;
        }
        .mode-selector { display: flex; gap: 5px; margin-bottom: 10px; }
        .mode-btn { flex: 1; height: 40px; border: none; border-radius: 4px; font-weight: bold; cursor: pointer; background: #444; color: #fff; }
        .mode-btn.active { background: #00ffcc; color: #000; }
        .mode-btn.eraser.active { background: #ff44aa; color: #fff; }
        .element-grid { display: grid; grid-template-columns: repeat(5, 1fr); gap: 5px; margin-bottom: 10px; }
        .el-btn { height: 40px; border: none; cursor: pointer; border-radius: 4px; font-weight: bold; font-size: 13px; color: #000; }
        .el-btn.active { outline: 2px solid #00ffcc; }
        #clear-btn { width: 100%; height: 35px; background: #ff4444; color: #fff; border: none; border-radius: 4px; font-weight: bold; }
    </style>
</head>
<body>

<div id="ui-panel">
    <div class="mode-selector">
        <button id="btn-add" class="mode-btn active" onclick="setMode('add')">入れる</button>
        <button id="btn-del" class="mode-btn eraser" onclick="setMode('del')">消す</button>
    </div>
    <div class="element-grid" id="grid"></div>
    <button id="clear-btn" onclick="clearAtoms()">全部リセット</button>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

<script>
    const ELEMENT_DATA = {
        'H': {color:0xffffff, mass:1, r:0.4}, 'He':{color:0xffb3e6, mass:4, r:0.45},
        'C': {color:0x444444, mass:12, r:0.7}, 'N': {color:0x3050F8, mass:14, r:0.65},
        'O': {color:0xFF0D0D, mass:16, r:0.6}, 'Na':{color:0xFE2323, mass:23, r:0.9},
        'Cl':{color:0x1FF01F, mass:35.5, r:0.8}, 'Fe':{color:0xFFA500, mass:55.8, r:1.1},
        'Au':{color:0xFFD700, mass:197, r:1.2}, 'U': {color:0xEB2222, mass:238, r:1.3}
    };

    let currentMode = 'add', currentType = 'H', atoms = [];
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    scene.add(new THREE.AmbientLight(0x909090));
    const light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(30, 50, 30);
    scene.add(light);
    
    // グリッドを確実に描画
    const grid = new THREE.GridHelper(200, 100, 0x444444, 0x222222);
    grid.position.y = -10;
    scene.add(grid);

    // UI初期化
    const uiGrid = document.getElementById('grid');
    Object.keys(ELEMENT_DATA).forEach(key => {
        const btn = document.createElement('button');
        btn.className = 'el-btn' + (key==='H'?' active':'');
        btn.style.background = '#' + ELEMENT_DATA[key].color.toString(16).padStart(6,'0');
        btn.innerText = key;
        btn.onclick = () => { currentType = key; document.querySelectorAll('.el-btn').forEach(b=>b.classList.remove('active')); btn.classList.add('active'); setMode('add'); };
        uiGrid.appendChild(btn);
    });

    function setMode(mode) {
        currentMode = mode;
        document.getElementById('btn-add').classList.toggle('active', mode === 'add');
        document.getElementById('btn-del').classList.toggle('active', mode === 'del');
    }

    function clearAtoms() {
        atoms.forEach(a => scene.remove(a.mesh));
        atoms = [];
        camera.position.set(0, 5, 20);
        controls.target.set(0, 0, 0);
    }

    class Atom {
        constructor(type, x, y, z) {
            const d = ELEMENT_DATA[type];
            this.mass = d.mass; this.r = d.r;
            this.mesh = new THREE.Mesh(new THREE.SphereGeometry(this.r, 12, 12), new THREE.MeshStandardMaterial({color:d.color}));
            this.mesh.position.set(x, y, z);
            this.mesh.userData = { parent: this };
            this.vel = new THREE.Vector3(0,0,0);
            scene.add(this.mesh);
        }
        update() {
            this.vel.y -= 0.005;
            this.mesh.position.add(this.vel);
            if(this.mesh.position.y < -10 + this.r) { this.mesh.position.y = -10 + this.r; this.vel.y *= -0.5; }
        }
    }

    // --- 確実に原子を見せるための初期化 ---
    function init() {
        clearAtoms();
        // 真ん中に金、左右に炭素を確実に置く
        atoms.push(new Atom('Au', 0, -5, 0));
        atoms.push(new Atom('C', 3, 0, 0));
        atoms.push(new Atom('C', -3, 0, 0));
        camera.position.set(0, 5, 20);
        camera.lookAt(0, 0, 0);
    }
    init();

    let isMoving = false;
    controls.addEventListener('start', () => { isMoving = true; });
    controls.addEventListener('end', () => { setTimeout(() => { isMoving = false; }, 100); });

    renderer.domElement.addEventListener('pointerup', (e) => {
        if(e.target.closest('#ui-panel') || isMoving) return;
        if (currentMode === 'add') {
            atoms.push(new Atom(currentType, (Math.random()-0.5)*5, 10, (Math.random()-0.5)*5));
        } else {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(atoms.map(a => a.mesh));
            if (intersects.length > 0) {
                const targetMesh = intersects[0].object;
                scene.remove(targetMesh);
                atoms = atoms.filter(a => a.mesh !== targetMesh);
            }
        }
    });

    function animate() {
        requestAnimationFrame(animate);
        for(let i=0; i<atoms.length; i++) {
            for(let j=i+1; j<atoms.length; j++) {
                const a=atoms[i], b=atoms[j];
                const d = a.mesh.position.distanceTo(b.mesh.position);
                if(d < a.r + b.r) {
                    const n = new THREE.Vector3().subVectors(b.mesh.position, a.mesh.position).normalize();
                    a.vel.add(n.clone().multiplyScalar(-0.02));
                    b.vel.add(n.multiplyScalar(0.02));
                }
            }
        }
        atoms.forEach(a => a.update());
        controls.update();
        renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>
