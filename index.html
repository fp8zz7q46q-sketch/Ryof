<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Pressure Point Physics</title>
    <style>
        body { font-family: -apple-system, sans-serif; background: #000; color: white; margin: 0; height: 100vh; overflow: hidden; touch-action: none; }
        #simCanvas { background: #000; width: 100%; height: 100vh; touch-action: none; display: block; }
        .overlay-stats {
            position: absolute; top: 10px; left: 10px; pointer-events: none;
            background: rgba(0,0,0,0.7); padding: 12px; border-radius: 10px; font-size: 11px;
            backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.2); z-index: 80;
        }
        #menuToggle {
            position: absolute; top: 10px; right: 10px; width: 50px; height: 50px;
            background: rgba(0, 123, 255, 0.9); border: none; border-radius: 50%;
            color: white; font-size: 24px; z-index: 110; cursor: pointer;
        }
        .side-panel {
            position: absolute; top: 0; right: -280px; width: 260px; height: 100vh;
            background: rgba(15, 15, 15, 0.98); backdrop-filter: blur(20px);
            transition: right 0.3s ease; border-left: 1px solid #444; z-index: 100;
            display: flex; flex-direction: column;
        }
        .side-panel.open { right: 0; }
        .panel-content { flex: 1; overflow-y: auto; padding: 80px 20px 40px; display: flex; flex-direction: column; gap: 15px; }
        .toggle-item { display: flex; align-items: center; justify-content: space-between; background: #222; padding: 10px; border-radius: 8px; font-size: 12px; }
        input[type=range] { width: 100%; height: 30px; accent-color: #007bff; cursor: pointer; }
        button { padding: 14px; border-radius: 10px; border: none; font-weight: bold; cursor: pointer; font-size: 13px; margin-top: 5px; }
    </style>
</head>
<body>

    <div class="overlay-stats">
        <div>粒子: <span id="totalDisplay">0</span></div>
        <div style="color:#ffcc00; font-weight: bold;">全体圧力: <span id="pressDisplay">0</span></div>
        <div id="localPressArea" style="color:#00ccff; font-weight: bold; margin-top: 5px; display:none;">
            指先圧力: <span id="localPressDisplay">0</span>
        </div>
    </div>

    <button id="menuToggle" onclick="toggleMenu()">☰</button>

    <div id="sidePanel" class="side-panel">
        <div class="panel-content">
            <div class="toggle-item"><span>スローモーション</span><input type="checkbox" id="slowCheck"></div>
            <div class="toggle-item"><span>軌跡を表示</span><input type="checkbox" id="trailCheck"></div>
            <div style="font-size:10px; color:#666;">スライダーで環境を調整</div>
            <input type="range" id="maxCountSlider" min="50" max="600" value="300">
            <input type="range" id="sliderGravity" min="0" max="100" value="15">
            <input type="range" id="sliderDown" min="5" max="100" value="40">
            <input type="range" id="sliderUp" min="1" max="100" value="30">
            <button onclick="toggleWall()" id="wallBtn" style="background:#28a745; color:white;">仕切り ON/OFF</button>
            <button onclick="resetSim()" style="background: #881111; color: white;">全リセット</button>
        </div>
    </div>

    <canvas id="simCanvas"></canvas>

    <script>
        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d', { alpha: false });
        let particles = [], wallY = 0, isWallActive = true, isDraggingWall = false, draggedParticle = null;
        let pressure = 0, localPressure = 0, lastSpawnTime = 0, touchPos = {x:0, y:0};
        const wallThickness = 25;

        function resize() {
            const ratio = window.devicePixelRatio || 1;
            canvas.width = window.innerWidth * ratio;
            canvas.height = window.innerHeight * ratio;
            if (wallY === 0) wallY = canvas.height / 2;
        }

        function toggleMenu() {
            const panel = document.getElementById('sidePanel');
            panel.classList.toggle('open');
            document.getElementById('menuToggle').innerText = panel.classList.contains('open') ? '✕' : '☰';
        }

        class Particle {
            constructor(area, mode) {
                this.baseR = 4; this.r = 4; this.isFixed = false;
                this.spawn(area, mode);
            }
            spawn(area, mode) {
                this.x = Math.random() * (canvas.width - 60) + 30;
                if (mode === 'heatSource') {
                    this.y = canvas.height - 30;
                    this.vy = -parseFloat(document.getElementById('sliderDown').value) * 0.5;
                    this.vx = (Math.random() - 0.5) * 15;
                } else {
                    this.y = 70; this.vy = 2; this.vx = (Math.random() - 0.5) * 5;
                }
            }
            update(dt) {
                if (this.isFixed || this === draggedParticle) return;
                const grav = parseFloat(document.getElementById('sliderGravity').value);
                const cold = parseFloat(document.getElementById('sliderUp').value);
                this.vy += (grav / 100) * dt;
                if (this.y < 130) {
                    const cool = (cold / 1000) * dt;
                    this.vx *= (1 - cool); this.vy *= (1 - cool);
                    if (this.vx*this.vx + this.vy*this.vy < 0.04) { this.isFixed = true; this.vx = 0; this.vy = 0; }
                }
                const speed = Math.sqrt(this.vx*this.vx + this.vy*this.vy);
                this.r = this.baseR + (speed * 0.35);
                if (this.r > 22) this.r = 22;
                let nX = this.x + this.vx * dt, nY = this.y + this.vy * dt;
                if (nX < this.r) { nX = this.r; this.vx = Math.abs(this.vx); pressure += this.vx; }
                else if (nX > canvas.width - this.r) { nX = canvas.width - this.r; this.vx = -Math.abs(this.vx); pressure += Math.abs(this.vx); }
                if (nY < this.r) { nY = this.r; this.vy = Math.abs(this.vy); pressure += this.vy; }
                else if (nY > canvas.height - this.r) { 
                    const h = parseFloat(document.getElementById('sliderDown').value);
                    nY = canvas.height - this.r; this.vy = -h * (0.4 + Math.random() * 0.4); pressure += Math.abs(this.vy);
                }
                if (isWallActive) {
                    const hT = wallThickness / 2;
                    if (nY + this.r > wallY - hT && nY - this.r < wallY + hT) {
                        if (this.y < wallY) { nY = wallY - hT - this.r; this.vy = -Math.abs(this.vy) * 0.95; }
                        else { nY = wallY + hT + this.r; this.vy = Math.abs(this.vy) * 0.95; }
                        pressure += Math.abs(this.vy);
                    }
                }
                this.x = nX; this.y = nY;
            }
            draw() {
                ctx.beginPath(); ctx.arc(this.x, this.y, this.r, 0, 7);
                const s = Math.sqrt(this.vx*this.vx + this.vy*this.vy);
                ctx.fillStyle = this.isFixed ? "#ffffff" : `hsl(${Math.max(0, 240 - s * 12)}, 90%, 60%)`;
                ctx.fill();
            }
        }

        function resolveCollision(p1, p2) {
            const dx = p2.x - p1.x, dy = p2.y - p1.y, dist = Math.sqrt(dx*dx + dy*dy);
            const minDist = p1.r + p2.r;
            if (dist < minDist && dist > 0) {
                const nx = dx/dist, ny = dy/dist, vDiff = (p1.vx - p2.vx)*nx + (p1.vy - p2.vy)*ny;
                if (vDiff > 0) {
                    const e = 0.95; p1.vx -= vDiff*nx*e; p1.vy -= vDiff*ny*e; p2.vx += vDiff*nx*e; p2.vy += vDiff*ny*e;
                }
                const overlap = (minDist - dist) / 2;
                p1.x -= nx * overlap; p1.y -= ny * overlap; p2.x += nx * overlap; p2.y += ny * overlap;
                if (p1.isFixed || p2.isFixed) { p1.isFixed = p2.isFixed = false; }
            }
        }

        const getPos = (e) => {
            const rect = canvas.getBoundingClientRect();
            const t = e.touches ? e.touches[0] : e;
            return { x: (t.clientX - rect.left) * (canvas.width/rect.width), y: (t.clientY - rect.top) * (canvas.height/rect.height) };
        };

        canvas.addEventListener('touchstart', e => {
            const p = getPos(e); touchPos = p;
            draggedParticle = particles.find(pt => Math.hypot(pt.x - p.x, pt.y - p.y) < 60);
            if (draggedParticle) { draggedParticle.isFixed = false; document.getElementById('localPressArea').style.display = 'block'; }
            else if (isWallActive && Math.abs(p.y - wallY) < 60) { isDraggingWall = true; document.getElementById('localPressArea').style.display = 'block'; }
            if (!document.getElementById('sidePanel').classList.contains('open')) e.preventDefault();
        }, { passive: false });

        window.addEventListener('touchmove', e => {
            const p = getPos(e); touchPos = p;
            if (draggedParticle) {
                const oldX = draggedParticle.x, oldY = draggedParticle.y;
                draggedParticle.x = p.x; draggedParticle.y = p.y;
                draggedParticle.vx = (p.x - oldX) * 0.8; draggedParticle.vy = (p.y - oldY) * 0.8;
                localPressure = Math.hypot(draggedParticle.vx, draggedParticle.vy) * 5;
                pressure += localPressure;
            } else if (isDraggingWall) {
                const oldY = wallY; wallY = Math.max(80, Math.min(canvas.height - 80, p.y));
                localPressure = Math.abs(wallY - oldY) * (particles.length / 8);
                pressure += localPressure;
            }
            if (!document.getElementById('sidePanel').classList.contains('open')) e.preventDefault();
        }, { passive: false });

        window.addEventListener('touchend', () => { 
            draggedParticle = null; isDraggingWall = false; 
            document.getElementById('localPressArea').style.display = 'none';
        });

        function toggleWall() { isWallActive = !isWallActive; document.getElementById('wallBtn').style.background = isWallActive ? "#28a745" : "#555"; }
        function resetSim() { particles = []; resize(); }

        function animate(time) {
            const dt = document.getElementById('slowCheck').checked ? 0.2 : 1.0;
            ctx.fillStyle = document.getElementById('trailCheck').checked ? "rgba(0,0,0,0.15)" : "#000";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = "rgba(0,120,255,0.12)"; ctx.fillRect(0,0,canvas.width,60);
            ctx.fillStyle = "rgba(255,50,0,0.12)"; ctx.fillRect(0,canvas.height-15,canvas.width,15);

            document.getElementById('pressDisplay').innerText = Math.floor(pressure);
            document.getElementById('localPressDisplay').innerText = Math.floor(localPressure);
            pressure *= 0.94; localPressure *= 0.8;

            const maxVal = parseInt(document.getElementById('maxCountSlider').value);
            if (time - lastSpawnTime > 160 && particles.length < maxVal) {
                const mid = isWallActive ? wallY : canvas.height/2;
                let up = 0; particles.forEach(p => { if (p.y < mid) up++; });
                particles.push(new Particle(up <= (particles.length-up) ? 'UP' : 'DOWN', up <= (particles.length-up) ? 'cold' : 'heatSource'));
                lastSpawnTime = time;
            }
            while(particles.length > maxVal) particles.splice(Math.floor(Math.random()*particles.length), 1);

            if (isWallActive) {
                ctx.fillStyle = isDraggingWall ? "#007bff" : "#444";
                ctx.fillRect(0, wallY - 12, canvas.width, wallThickness);
            }

            // 指圧のビジュアルエフェクト
            if (draggedParticle || isDraggingWall) {
                ctx.beginPath(); ctx.arc(touchPos.x, touchPos.y, 30 + localPressure * 0.5, 0, 7);
                ctx.strokeStyle = `rgba(0, 200, 255, ${Math.min(0.6, localPressure / 40)})`;
                ctx.lineWidth = 3; ctx.stroke();
            }

            const steps = dt < 1 ? 1 : 2; 
            for(let s=0; s<steps; s++) {
                for (let i = 0; i < particles.length; i++) {
                    const p1 = particles[i];
                    for (let j = i + 1; j < particles.length; j++) {
                        if (Math.abs(p1.x - particles[j].x) < 45 && Math.abs(p1.y - particles[j].y) < 45) resolveCollision(p1, particles[j]);
                    }
                    p1.update(dt/steps);
                }
            }
            particles.forEach(p => p.draw());
            document.getElementById('totalDisplay').innerText = particles.length;
            requestAnimationFrame(animate);
        }
        window.onload = () => { resize(); animate(0); };
    </script>
</body>
</html>
