<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Atomic 25 - Labels & Ghost</title>
    <style>
        html, body { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background: #000; touch-action: none; }
        #ui-panel {
            position: absolute; top: 5px; left: 5px;
            background: rgba(0, 0, 0, 0.9); padding: 8px;
            border-radius: 12px; color: #fff; border: 1px solid #555;
            width: 300px; z-index: 1000; font-family: sans-serif;
            max-height: 90vh; display: flex; flex-direction: column;
        }
        .scroll-area { overflow-y: auto; flex-grow: 1; padding-right: 5px; }
        .element-grid { display: grid; grid-template-columns: repeat(5, 1fr); gap: 4px; margin-bottom: 10px; }
        .el-btn { height: 42px; border: none; cursor: pointer; border-radius: 6px; font-weight: bold; font-size: 11px; color: #000; display: flex; flex-direction: column; align-items: center; justify-content: center; }
        .active { outline: 3px solid #00ffcc; box-shadow: 0 0 10px #00ffcc; }
        #clear-btn { width: 100%; min-height: 35px; background: #ff4444; color: #fff; border: none; border-radius: 6px; font-weight: bold; }
        .info { font-size: 10px; color: #00ffcc; text-align: center; margin-top: 8px; }
        /* 電荷ラベル用のスタイル */
        .atom-label {
            color: white; font-family: sans-serif; font-weight: bold; font-size: 12px;
            text-shadow: 1px 1px 2px black; pointer-events: none; white-space: nowrap;
        }
        ::-webkit-scrollbar { width: 4px; }
        ::-webkit-scrollbar-thumb { background: #555; border-radius: 10px; }
    </style>
</head>
<body>

<div id="ui-panel">
    <div class="scroll-area"><div class="element-grid" id="grid"></div></div>
    <button id="clear-btn" onclick="clearAtoms()">全部リセット</button>
    <div class="info">25元素搭載。電荷表示を固定しました。<br>ゴーストに合わせてタップで生成！</div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/renderers/CSS2DRenderer.js"></script>

<script>
    const ELEMENT_DATA = {
        'H':  {c:0xffffff, r:0.4, h:1, q:1},   'He': {c:0xffc0cb, r:0.4, h:0, q:0},
        'Li': {c:0xcc80ff, r:0.5, h:1, q:1},   'Be': {c:0xc2ff00, r:0.4, h:2, q:2},
        'B':  {c:0xffb5b5, r:0.6, h:3, q:3},   'C':  {c:0x555555, r:0.7, h:4, q:4},
        'N':  {c:0x3050f8, r:0.7, h:3, q:3},   'O':  {c:0xff0d0d, r:0.6, h:2, q:-2},
        'F':  {c:0x90e050, r:0.5, h:1, q:-1},  'Ne': {c:0xb3e3f5, r:0.5, h:0, q:0},
        'Na': {c:0xab5cf2, r:0.9, h:1, q:1},   'Mg': {c:0x8aff00, r:0.8, h:2, q:2},
        'Al': {c:0xbfa6a6, r:0.9, h:3, q:3},   'Si': {c:0xf0c8a0, r:1.0, h:4, q:4},
        'P':  {c:0xff8000, r:0.9, h:3, q:5},   'S':  {c:0xffff30, r:0.9, h:2, q:-2},
        'Cl': {c:0x1ff01f, r:0.8, h:1, q:-1},  'Ar': {c:0x80d1e3, r:0.8, h:0, q:0},
        'K':  {c:0x8f40d4, r:1.1, h:1, q:1},   'Ca': {c:0x3dffba, r:1.0, h:2, q:2},
        'Ti': {c:0xbfc2c7, r:1.0, h:4, q:4},   'Fe': {c:0xe06633, r:1.0, h:3, q:3},
        'Cu': {c:0xc88033, r:1.0, h:2, q:2},   'Ag': {c:0xc0c0c0, r:1.1, h:1, q:1},
        'Au': {c:0xffd700, r:1.1, h:1, q:1}
    };

    let atoms = [], currentType = 'H';
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(0, 10, 20);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // ラベル用レンダラーの設定
    const labelRenderer = new THREE.CSS2DRenderer();
    labelRenderer.setSize(window.innerWidth, window.innerHeight);
    labelRenderer.domElement.style.position = 'absolute';
    labelRenderer.domElement.style.top = '0px';
    labelRenderer.domElement.style.pointerEvents = 'none';
    document.body.appendChild(labelRenderer.domElement);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    scene.add(new THREE.AmbientLight(0xcccccc));
    const light = new THREE.PointLight(0xffffff, 1);
    light.position.set(20, 30, 20);
    scene.add(light);
    scene.add(new THREE.GridHelper(80, 40, 0x444444, 0x222222));

    const ghostGeo = new THREE.SphereGeometry(1, 16, 16);
    const ghostMat = new THREE.MeshStandardMaterial({ transparent: true, opacity: 0.4, wireframe: true, color: 0x00ffcc });
    const ghostMesh = new THREE.Mesh(ghostGeo, ghostMat);
    scene.add(ghostMesh);

    const uiGrid = document.getElementById('grid');
    Object.keys(ELEMENT_DATA).forEach(key => {
        const d = ELEMENT_DATA[key];
        const btn = document.createElement('button');
        btn.className = 'el-btn' + (key==='H'?' active':'');
        btn.style.background = '#' + d.c.toString(16).padStart(6,'0');
        btn.innerHTML = `<div>${key}</div><div style="font-size:7.5px; opacity:0.7">${d.q>0?'+':''}${d.q}</div>`;
        btn.onclick = (e) => { 
            e.stopPropagation(); currentType = key; 
            document.querySelectorAll('.el-btn').forEach(b=>b.classList.remove('active')); 
            btn.classList.add('active'); 
            ghostMesh.scale.setScalar(ELEMENT_DATA[key].r);
        };
        uiGrid.appendChild(btn);
    });

    function clearAtoms() { atoms.forEach(a => { scene.remove(a.mesh); scene.remove(a.label); }); atoms = []; }

    class Atom {
        constructor(type, pos) {
            const d = ELEMENT_DATA[type];
            this.type = type; this.r = d.r; this.maxHands = d.h; this.charge = d.q;
            this.connections = [];
            this.mesh = new THREE.Mesh(new THREE.SphereGeometry(this.r, 16, 16), new THREE.MeshStandardMaterial({color:d.c, roughness:0.2, metalness:0.3}));
            this.mesh.position.copy(pos);
            this.vel = new THREE.Vector3();
            
            // 電荷ラベルの作成
            const div = document.createElement('div');
            div.className = 'atom-label';
            div.textContent = `${type}(${d.q>0?'+':''}${d.q})`;
            this.label = new THREE.CSS2DObject(div);
            this.label.position.set(0, this.r + 0.3, 0);
            this.mesh.add(this.label); // メッシュに追従させる
            
            scene.add(this.mesh);
        }
    }

    function getGroupInfo(atom, visited = new Set()) {
        visited.add(atom);
        let totalCharge = atom.charge;
        let members = [atom];
        for (let conn of atom.connections) {
            if (!visited.has(conn)) {
                let res = getGroupInfo(conn, visited);
                totalCharge += res.totalCharge;
                members = members.concat(res.members);
            }
        }
        return { totalCharge, members };
    }

    let tapStartTime;
    renderer.domElement.addEventListener('pointerdown', () => { tapStartTime = Date.now(); });
    renderer.domElement.addEventListener('pointerup', (e) => {
        if (e.target.closest('#ui-panel')) return;
        if (Date.now() - tapStartTime < 250) {
            atoms.push(new Atom(currentType, ghostMesh.position));
        }
    });

    function animate() {
        requestAnimationFrame(animate);

        const direction = new THREE.Vector3();
        camera.getWorldDirection(direction);
        const spawnPos = new THREE.Vector3().copy(camera.position).add(direction.multiplyScalar(8));
        ghostMesh.position.copy(spawnPos);

        let isOverlapping = false;
        atoms.forEach(a => { if (ghostMesh.position.distanceTo(a.mesh.position) < (ELEMENT_DATA[currentType].r + a.r)) isOverlapping = true; });
        ghostMat.color.setHex(isOverlapping ? 0xff4444 : 0x00ffcc);

        let groups = [];
        let processedAtoms = new Set();
        atoms.forEach(a => { if (!processedAtoms.has(a)) { let info = getGroupInfo(a); info.members.forEach(m => processedAtoms.add(m)); groups.push(info); } });

        for(let step=0; step<2; step++) {
            for(let i=0; i<atoms.length; i++) {
                const a = atoms[i];
                const groupA = groups.find(g => g.members.includes(a));
                for(let j=i+1; j<atoms.length; j++) {
                    const b = atoms[j];
                    const groupB = groups.find(g => g.members.includes(b));
                    if (groupA === groupB) continue;
                    const diff = new THREE.Vector3().subVectors(b.mesh.position, a.mesh.position);
                    const realDist = diff.length();
                    const minDist = a.r + b.r;
                    const distSq = realDist * realDist + 2.0;
                    let forceMag = -0.012 * (groupA.totalCharge * groupB.totalCharge) / distSq;
                    if (forceMag > 0 && realDist < minDist * 2.5) {
                        if (a.connections.length < a.maxHands && b.connections.length < b.maxHands) {
                            forceMag *= (realDist - minDist) / minDist;
                            if (realDist < minDist + 0.1 && !a.connections.includes(b)) { a.connections.push(b); b.connections.push(a); }
                        } else { forceMag = -0.01; }
                    }
                    const force = diff.normalize().multiplyScalar(forceMag);
                    a.vel.add(force); b.vel.sub(force);
                }
            }
            for(let i=0; i<atoms.length; i++) {
                for(let j=i+1; j<atoms.length; j++) {
                    const a = atoms[i]; const b = atoms[j];
                    const diff = new THREE.Vector3().subVectors(b.mesh.position, a.mesh.position);
                    const dist = diff.length();
                    const minDist = a.r + b.r;
                    if (dist < minDist) {
                        const pushOut = diff.normalize().multiplyScalar((minDist - dist) * 0.52);
                        a.mesh.position.sub(pushOut); b.mesh.position.add(pushOut);
                        const dot = (new THREE.Vector3().subVectors(b.vel, a.vel)).dot(diff.normalize());
                        if (dot < 0) { const imp = diff.normalize().multiplyScalar(dot * 0.6); a.vel.add(imp); b.vel.sub(imp); }
                    }
                }
            }
        }

        atoms.forEach(a => { a.mesh.position.add(a.vel); a.vel.multiplyScalar(0.93); });
        controls.update();
        renderer.render(scene, camera);
        labelRenderer.render(scene, camera); // ラベルの描画
    }
    animate();
</script>
</body>
</html>
